tolerance = np.finfo(np.float).eps * 10
S = {index for index, x in np.ndenumerate(X)}
A,B = bihierarchy_test(constraint_structure)
A.append(S), B.append(S)

for x in S:
  A.append({x}), B.append({x})

for x in S:
  constraint_structure.update({frozenset({x}):(0,1)})
  
R1 = nx.DiGraph()
for x in A:
  for y in A:
    if x < y and not any(x < z < y for z in A):
      R1.add_edge(frozenset(y),frozenset(x),weight=sum([X[i] for i in x]), min_capacity = constraint_structure[frozenset(x)][0], max_capacity = constraint_structure[frozenset(x)][1])

R2 = nx.DiGraph()
for x in B:
  for y in B:
    if y < x and not any(y < z < x for z in B):
      R2.add_edge((frozenset(y),'p'),(frozenset(x),'p'),weight = sum( [X[i] for i in y]), min_capacity = constraint_structure[frozenset(y)][0], max_capacity = constraint_structure[frozenset(y)][1])

G = nx.compose(R1,R2)

for index, x in np.ndenumerate(X):
  G.add_edge(frozenset({index}), (frozenset({index}),'p'), weight=x, min_capacity = 0, max_capacity = 1)

H=[(G,1)]
solution=[]

while len(H) > 0:
  if any(tolerance < x < 1 - tolerance for x in [d['weight'] for (u,v,d) in H[0][0].edges(data=True) if u in [frozenset({x}) for x in S]]):
    H.extend(generalized_birkhoff_von_neumann_iterator([H.pop(0)]))
  else:
    solution.append(H.pop(0))

solution_columns_and_probs = []

for y in solution:
  solution_columns_and_probs.append([[(u,d['weight']) for (u,v,d) in y[0].edges(data=True) if u in [frozenset({x}) for x in S]],y[1]])

solution_zeroed = []

for z in solution_columns_and_probs:
  list = []
  for y in z[0]:
    if y[1] < tolerance:
      list.append((y[0],0))
    elif y[1] > 1-tolerance:
      list.append((y[0],1))
  solution_zeroed.append([list,z[1]])

assgs = []
coeffs = []

for a in solution_zeroed:
  Y = np.zeros(X.shape)
  for x in a[0]:
    for y in x[0]:
      Y[y]=x[1]
  assgs.append(Y)
  coeffs.append(a[1])

list = []

for idx, x in enumerate(solution_zeroed):
  if all(x[0]!= z[0] for z in [solution_zeroed[i] for i in list]):
    list.append(idx)

solution_simplified = []

for i in list:
  solution_simplified.append([solution_zeroed[i][0],sum([x[1] for x in solution_zeroed if x[0]==solution_zeroed[i][0]])])

assignments = []
coefficients = []

for a in solution_simplified:
  Y = np.zeros(X.shape)
  for x in a[0]:
    for y in x[0]:
      Y[y]=x[1]
  assignments.append(Y)
  coefficients.append(a[1])

sum(i[1]*i[0] for i in zip(coefficients, assignments))
